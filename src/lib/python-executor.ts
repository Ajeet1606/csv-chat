import Docker from 'dockerode';
import * as fs from 'fs';

const docker = new Docker();

const SANDBOX_IMAGE = 'csv-chat-python-sandbox:latest';
const TIMEOUT_MS = 30000; // 30 seconds
const MEMORY_LIMIT = 512 * 1024 * 1024; // 512MB in bytes
const CPU_QUOTA = 100000; // 1.0 CPU (100% of one core)

export interface ExecutionResult {
  success: boolean;
  result?: unknown;
  error?: string;
  stderr?: string;
  executionTime: number;
}

/**
 * Executes Python code in a sandboxed Docker container with the CSV file pre-loaded as df
 * @param code - The Python code to execute (generated by LLM)
 * @param csvFilePath - Absolute path to the CSV file on the host
 * @returns ExecutionResult with parsed JSON output from stdout
 */
export async function executePythonCode(
  code: string,
  csvFilePath: string
): Promise<ExecutionResult> {
  const startTime = Date.now();

  console.log('=== Python Executor: Starting Execution ===');
  console.log('CSV File Path:', csvFilePath);
  console.log('Generated Code Length:', code.length, 'characters');
  console.log('===========================================');

  // Verify CSV file exists
  if (!fs.existsSync(csvFilePath)) {
    console.error('‚ùå CSV file not found:', csvFilePath);
    return {
      success: false,
      error: 'CSV file not found',
      executionTime: Date.now() - startTime,
    };
  }

  let container: Docker.Container | null = null;

  try {
    // Prepend code to load CSV into df
    const fullCode = `import warnings
  warnings.filterwarnings("ignore")
  import pandas as pd
  import numpy as np
  import json

  # Load CSV file into dataframe
  df = pd.read_csv('/data/input.csv')

# User's generated code
${code}
`;

    console.log('=== Full Code to Execute ===');
    console.log(fullCode);
    console.log('============================');

    // Create container with security restrictions
    container = await docker.createContainer({
      Image: SANDBOX_IMAGE,
      Cmd: ['python', '-c', fullCode],
      HostConfig: {
        // Mount CSV as read-only
        Binds: [`${csvFilePath}:/data/input.csv:ro`],
        // Memory limit
        Memory: MEMORY_LIMIT,
        // CPU limit (100000 = 1.0 CPU)
        CpuQuota: CPU_QUOTA,
        CpuPeriod: 100000,
        // Disable network access for security
        NetworkMode: 'none',
        // Auto-remove container after execution
        AutoRemove: true,
      },
      // Run as non-root user (defined in Dockerfile)
      User: 'sandbox',
    });

    // Attach to container to capture stdout/stderr
    const stream = await container.attach({
      stream: true,
      stdout: true,
      stderr: true,
    });

    let stdout = '';
    let stderr = '';

    // Demultiplex Docker streams (stdout and stderr are multiplexed)
    container.modem.demuxStream(
      stream,
      {
        write: (chunk: Buffer) => {
          stdout += chunk.toString();
        },
      },
      {
        write: (chunk: Buffer) => {
          stderr += chunk.toString();
        },
      }
    );

    // Start the container
    console.log('üê≥ Starting Docker container...');
    await container.start();

    // Wait for container to finish with timeout
    const timeoutPromise = new Promise<never>((_, reject) =>
      setTimeout(() => reject(new Error('Execution timeout')), TIMEOUT_MS)
    );

    try {
      await Promise.race([container.wait(), timeoutPromise]);
      console.log('‚úÖ Container execution completed');
    } catch (error) {
      console.error('‚è±Ô∏è  Execution timeout - stopping container');
      // Timeout occurred, try to stop the container
      try {
        await container.stop({ t: 1 });
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
      } catch (stopError) {
        // Container might already be stopped/removed
      }
      throw error;
    }

    const executionTime = Date.now() - startTime;

    console.log('=== Execution Results ===');
    console.log('Execution Time:', executionTime, 'ms');
    console.log('--- STDOUT ---');
    console.log(stdout);
    console.log('--- STDERR ---');
    console.log(stderr);
    console.log('========================');

    // Parse JSON output from stdout
    const trimmedOutput = stdout.trim();
    if (!trimmedOutput) {
      console.error('‚ùå No output generated');
      return {
        success: false,
        error: 'No output generated',
        stderr: stderr.trim(),
        executionTime,
      };
    }

    try {
      const result = JSON.parse(trimmedOutput);

      // Check if the result contains an error field
      if (result.error) {
        console.error('‚ùå Python code returned error:', result.error);
        return {
          success: false,
          error: result.error,
          stderr: stderr.trim(),
          executionTime,
        };
      }

      console.log('‚úÖ Successfully parsed JSON result');
      return {
        success: true,
        result,
        stderr: stderr.trim() || undefined,
        executionTime,
      };
    } catch (parseError) {
      console.error('‚ùå Failed to parse JSON output:', parseError);
      console.error('Raw output was:', trimmedOutput);
      return {
        success: false,
        error: `Failed to parse JSON output: ${parseError instanceof Error ? parseError.message : 'Unknown error'}`,
        stderr: stderr.trim() || `Raw output: ${trimmedOutput}`,
        executionTime,
      };
    }
  } catch (error) {
    const executionTime = Date.now() - startTime;
    console.error('‚ùå Execution error:', error);

    // Clean up container if it exists and wasn't auto-removed
    if (container) {
      try {
        await container.remove({ force: true });
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
      } catch (removeError) {
        // Container might already be removed (AutoRemove: true)
      }
    }

    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown execution error',
      executionTime,
    };
  }
}
